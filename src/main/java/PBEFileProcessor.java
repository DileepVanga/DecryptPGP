import java.io.*;
import java.security.NoSuchProviderException;
import java.security.Security;
import java.util.Iterator;
import java.util.logging.Logger;

import com.sun.xml.internal.ws.util.StreamUtils;
//import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FileUtils;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.openpgp.*;
import org.bouncycastle.openpgp.jcajce.JcaPGPObjectFactory;
import org.bouncycastle.openpgp.operator.PGPDataDecryptor;
import org.bouncycastle.openpgp.operator.jcajce.JcaKeyFingerprintCalculator;
import org.bouncycastle.openpgp.operator.jcajce.JcaPGPDigestCalculatorProviderBuilder;
import org.bouncycastle.openpgp.operator.jcajce.JcePBEDataDecryptorFactoryBuilder;
import org.bouncycastle.util.io.Streams;

/**
 * A simple utility class that encrypts/decrypts password based
 * encryption files.
 * <p>
 * To encrypt a file: PBEFileProcessor -e [-ai] fileName passPhrase.<br>
 * If -a is specified the output file will be "ascii-armored".<br>
 * If -i is specified the output file will be "integrity protected".
 * <p>
 * To decrypt: PBEFileProcessor -d fileName passPhrase.
 * <p>
 * Note: this example will silently overwrite files, nor does it pay any attention to
 * the specification of "_CONSOLE" in the filename. It also expects that a single pass phrase
 * will have been used.
 */
public class PBEFileProcessor
{
	private static void decryptFile(String inputFileName, char[] passPhrase)
			throws IOException, NoSuchProviderException, PGPException
	{
		InputStream in = new BufferedInputStream(new FileInputStream(inputFileName));
		decryptFile(in, passPhrase);
		in.close();
	}

	/*
	 * decrypt the passed in message stream
	 */
	private static void decryptFile(
			InputStream    in,
			char[]         passPhrase)
			throws IOException, NoSuchProviderException, PGPException
	{
		in = PGPUtil.getDecoderStream(in);

		JcaPGPObjectFactory        pgpF = new JcaPGPObjectFactory(in);
		PGPEncryptedDataList    enc;
		Object                  o = pgpF.nextObject();

		//
		// the first object might be a PGP marker packet.
		//
		if (o instanceof PGPEncryptedDataList)
		{
			enc = (PGPEncryptedDataList)o;
		}
		else
		{
			enc = (PGPEncryptedDataList)pgpF.nextObject();
		}

		PGPPBEEncryptedData     pbe = (PGPPBEEncryptedData)enc.get(0);

		InputStream clear = pbe.getDataStream(new JcePBEDataDecryptorFactoryBuilder(new JcaPGPDigestCalculatorProviderBuilder().setProvider("BC").build()).setProvider("BC").build(passPhrase));

		JcaPGPObjectFactory        pgpFact = new JcaPGPObjectFactory(clear);

		//
		// if we're trying to read a file generated by someone other than us
		// the data might not be compressed, so we check the return type from
		// the factory and behave accordingly.
		//
		o = pgpFact.nextObject();
		if (o instanceof PGPCompressedData)
		{
			PGPCompressedData   cData = (PGPCompressedData)o;

			pgpFact = new JcaPGPObjectFactory(cData.getDataStream());

			o = pgpFact.nextObject();
		}

		PGPLiteralData ld = (PGPLiteralData)o;
		InputStream unc = ld.getInputStream();

		OutputStream fOut = new BufferedOutputStream(new FileOutputStream("/Users/dileepvanga/Desktop/encrypted/"+ld.getFileName()));

		Streams.pipeAll(unc, fOut);
		File templateFile = FileUtils.getFile("/Users/dileepvanga/Desktop/encrypted/"+ld.getFileName());

		templateFile.getAbsolutePath();
		fOut.close();

		if (pbe.isIntegrityProtected())
		{
			if (!pbe.verify())
			{
				System.err.println("message failed integrity check");
			}
			else
			{
				System.err.println("message integrity check passed");
			}
		}
		else
		{
			System.err.println("no message integrity check");
		}
	}

	static PGPPublicKey readPublicKey(String fileName) throws IOException, PGPException
	{
		InputStream keyIn = new BufferedInputStream(new FileInputStream(fileName));
		PGPPublicKey pubKey = readPublicKey(keyIn);
		keyIn.close();
		return pubKey;
	}

	/**
	 * A simple routine that opens a key ring file and loads the first available key
	 * suitable for encryption.
	 *
	 * @param input data stream containing the public key data
	 * @return the first public key found.
	 * @throws IOException
	 * @throws PGPException
	 */
	static PGPPublicKey readPublicKey(InputStream input) throws IOException, PGPException
	{
		PGPPublicKeyRingCollection pgpPub = new PGPPublicKeyRingCollection(
				PGPUtil.getDecoderStream(input), new JcaKeyFingerprintCalculator());

		//
		// we just loop through the collection till we find a key suitable for encryption, in the real
		// world you would probably want to be a bit smarter about this.
		//

		Iterator keyRingIter = pgpPub.getKeyRings();
		while (keyRingIter.hasNext())
		{
			PGPPublicKeyRing keyRing = (PGPPublicKeyRing)keyRingIter.next();

			Iterator keyIter = keyRing.getPublicKeys();
			while (keyIter.hasNext())
			{
				PGPPublicKey key = (PGPPublicKey)keyIter.next();

				if (key.isEncryptionKey())
				{
					return key;
				}
			}
		}

		throw new IllegalArgumentException("Can't find encryption key in key ring.");
	}


	public static void decryptFileTest(InputStream inputStream, String passPhrase) throws IOException,
			NoSuchProviderException {

		if (Security.getProvider(BouncyCastleProvider.PROVIDER_NAME) == null) {
			Security.addProvider(new BouncyCastleProvider());
		}
		inputStream = PGPUtil.getDecoderStream(inputStream);

		JcaPGPObjectFactory pgpF = new JcaPGPObjectFactory(inputStream);
		PGPEncryptedDataList enc;
		Object pgpfObject = pgpF.nextObject();

		if (pgpfObject instanceof PGPEncryptedDataList) {
			enc = (PGPEncryptedDataList) pgpfObject;
		} else {
			enc = (PGPEncryptedDataList) pgpF.nextObject();
		}

		PGPPBEEncryptedData pbe = (PGPPBEEncryptedData) enc.get(0);

		InputStream clear;
		try {
			clear = pbe.getDataStream(new JcePBEDataDecryptorFactoryBuilder(new JcaPGPDigestCalculatorProviderBuilder()
					.setProvider(BouncyCastleProvider.PROVIDER_NAME).build())
					.setProvider(BouncyCastleProvider.PROVIDER_NAME).build(passPhrase.toCharArray()));

//			pbe.getDataStream(new JcePBEDataDecryptorFactoryBuilder(new JcaPGPDigestCalculatorProviderBuilder()
//							.setProvider(BouncyCastleProvider.PROVIDER_NAME).build()).setProvider(BouncyCastleProvider.PROVIDER_NAME)
//							.build(passPhrase.toCharArray()));

			JcaPGPObjectFactory pgpFact = new JcaPGPObjectFactory(clear);
			pgpfObject = pgpFact.nextObject();
			if (pgpfObject instanceof PGPCompressedData) {
				PGPCompressedData cData = (PGPCompressedData) pgpfObject;
				pgpFact = new JcaPGPObjectFactory(cData.getDataStream());
				pgpfObject = pgpFact.nextObject();
			}

			PGPLiteralData ld = (PGPLiteralData) pgpfObject;
			//return StreamUtils.convertStream(ld.getInputStream());
		} catch (PGPException e) {
			//throw new IOException(e);
			System.out.println(e);
		}
	}

	private static final String FOLDER = "/Users/dileepvanga/Desktop/encrypted/eapxap2015testfile.txt.pgp";
	private static final String PASS = "Our admissions management and enrollment marketing automation";

	public static void main(
			String[] args)
			throws Exception
	{



		Security.addProvider(new BouncyCastleProvider());
		//Security.insertProviderAt(new BouncyCastleProvider(), 0);

		//PGPPublicKey key = readPublicKey(FOLDER);
		String[] gpgCommands = new String[] {
				"gpg",
				"--passphrase",
				"Our admissions management and enrollment marketing automation",
				"--decrypt",
				"/Users/dileepvanga/Desktop/encrypted/eapxap2015testfile.txt.pgp"
		};

//		Process gpgProcess = Runtime.getRuntime().exec(gpgCommands);
//		BufferedReader gpgOutput = new BufferedReader(new InputStreamReader(gpgProcess.getInputStream()));
//		BufferedReader gpgError = new BufferedReader(new InputStreamReader(gpgProcess.getErrorStream()));
//		File encryptedFile = new File(FOLDER);
		//byte[]  encryptedByteArray = FileUtils.readFileToByteArray(encryptedFile);


		decryptFile(FOLDER, PASS.toCharArray());
//		 if (args[0].equals("-d"))
//		{
//			decryptFile(args[1], args[2].toCharArray());
//		}
//		else
//		{
//			System.err.println("usage: PBEFileProcessor -e [-ai]|-d file passPhrase");
//		}
	//	=====================
//		String[] cmd = new String[];
//		int i = 7;
//		cmd[i++] = "gpg";
//		cmd[i++] = "--passphrase-fd";
//		cmd[i++] = "0";
//		cmd[i++] = "--output";
//		cmd[i++] = "plaintext.txt";
//		cmd[i++] = "--decrypt";
//		cmd[i++] = "encrypted.gpg";
//
//		Process p = Runtime.getRuntime().exec(cmd);
//
//		// Write the passphrase out to the std input of the exec command
//		BufferedWriter out = new BufferedWriter(new OutputStreamWriter(p.getOutputStream()));
//		try
//		{
//			out.write("Our admissions management and enrollment marketing automation");
//			out.close();
//		}
//		catch(IOException io)
//		{
//			System.out.println("Exception at write! " + io.getMessage ());
//		}
//
//		// Read the result from the standard output
//		BufferedReader in = new BufferedReader(
//				new InputStreamReader(p.getInputStream()));
//		String line = null;
//		while ((line = in.readLine()) != null) {
//			System.out.println(line);
//		}
//
//		// Wait for the process to finish
//		p.waitFor();
//
//		System.out.println("Exit Code from command: " + p.exitValue() );
//
//		// Ensure that the child process is terminated properly
//		p.destroy();
//	}
		}
}